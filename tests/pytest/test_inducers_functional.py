from __future__ import annotations

import pytest
from palimpzest.core.data.graph_dataset import GraphDataset, GraphNode, GraphEdge

@pytest.fixture
def simple_graph():
    """Creates a simple graph with some nodes having text and embeddings."""
    g = GraphDataset(graph_id="test_graph_functional")
    
    # Nodes for text-based induction
    g.add_node(GraphNode(id="n1", text="The quick brown fox", attrs={"name": "Fox"}))
    g.add_node(GraphNode(id="n2", text="jumps over the lazy dog", attrs={"name": "Dog"}))
    g.add_node(GraphNode(id="n3", text="The fox is quick", attrs={"name": "QuickFox"}))
    
    # Nodes for embedding-based induction (normalized vectors for easy cosine sim)
    # v1 = [1, 0], v2 = [0, 1], v3 = [0.707, 0.707] (45 deg)
    # sim(v1, v2) = 0
    # sim(v1, v3) ~ 0.707
    g.add_node(GraphNode(id="e1", embedding=[1.0, 0.0], attrs={"type": "vec"}))
    g.add_node(GraphNode(id="e2", embedding=[0.0, 1.0], attrs={"type": "vec"}))
    g.add_node(GraphNode(id="e3", embedding=[0.70710678, 0.70710678], attrs={"type": "vec"}))
    
    return g

def test_knn_similarity_topk(simple_graph):
    g = simple_graph
    
    # Add Top-K=1 KNN induction
    spec_id = g.add_knn_similarity_topk(k=1, edge_type="sim_top1")
    
    # Run full induction
    edges = g.run_induction(spec_id, mode="full")
    
    # e1 should match e3 (sim ~0.7) better than e2 (sim 0)
    # e2 should match e3 (sim ~0.7) better than e1 (sim 0)
    # e3 should match e1 or e2 (both ~0.7). Since it's top-1, it picks one.
    
    # Check edges exist
    edge_pairs = sorted([(e.src_node_id, e.dst_node_id) for e in edges])
    
    # We expect e1->e3, e2->e3. e3->e1 OR e3->e2.
    # Also symmetric edges are generated by default in add_knn_similarity_topk (symmetric=True)
    # So if e1->e3 is created, e3->e1 is also created.
    
    # Let's verify we have edges and they make sense
    assert len(edges) > 0
    for e in edges:
        assert e.edge_type == "sim_top1"
        # Verify we didn't link orthogonal vectors e1 and e2
        if e.src_node_id == "e1": assert e.dst_node_id != "e2"
        if e.src_node_id == "e2": assert e.dst_node_id != "e1"

def test_knn_similarity_threshold(simple_graph):
    g = simple_graph
    
    # Add Threshold=0.5 KNN induction
    spec_id = g.add_knn_similarity_threshold(threshold=0.5, edge_type="sim_thresh")
    
    edges = g.run_induction(spec_id, mode="full")
    
    # e1-e3 (0.7) > 0.5 -> Match
    # e2-e3 (0.7) > 0.5 -> Match
    # e1-e2 (0.0) < 0.5 -> No Match
    
    pairs = sorted([(e.src_node_id, e.dst_node_id) for e in edges])
    # Symmetric=True means we get both directions
    expected = [
        ("e1", "e3"), ("e2", "e3"), 
        ("e3", "e1"), ("e3", "e2")
    ]
    assert pairs == expected

def test_predicate_induction_text_contains(simple_graph):
    g = simple_graph
    
    # Induce edge if src.text contains dst.attrs.name
    # n1: "The quick brown fox" contains "Fox" (n1.name)? No, "Fox" is n1. 
    # Wait, predicate induction usually checks src vs dst.
    # n1 text contains "Fox"? Yes.
    # n3 text "The fox is quick" contains "Fox"? Yes.
    
    # Let's define: src.text contains dst.attrs.name
    # n1 ("...fox") contains n1.name ("Fox")? Yes (case insensitive usually?)
    # n1 ("...fox") contains n3.name ("QuickFox")? No.
    
    # Let's use a clearer example.
    # n1 text: "The quick brown fox"
    # n3 name: "Fox" (Let's change n3 name to "Fox" for test clarity or rely on n1)
    
    # Let's add a specific node to target
    g.add_node(GraphNode(id="target", attrs={"name": "Fox"}))
    
    # We want to link any node whose TEXT contains "Fox" to the "target" node.
    # n1: "...fox" -> target ("Fox")
    # n3: "...fox..." -> target ("Fox")
    
    spec_id = g.add_predicate_induction(
        edge_type="mentions",
        generator_kind="all_pairs", # Simple generator
        predicates=[{
            "kind": "text_contains",
            "params": {
                "source_field": "text",
                "target_fields": ["attrs.name"],
                "boundaries": False # Simple substring
            }
        }],
        symmetric=False
    )
    
    edges = g.run_induction(spec_id, mode="full")
    
    # Check for n1->target and n3->target
    pairs = [(e.src_node_id, e.dst_node_id) for e in edges]
    assert ("n1", "target") in pairs
    assert ("n3", "target") in pairs
    
    # n2 "jumps over..." does not contain "Fox"
    assert ("n2", "target") not in pairs

def test_incremental_inducement_workflow(simple_graph):
    g = simple_graph
    
    # 1. Register inducer (Threshold KNN)
    spec_id = g.add_knn_similarity_threshold(threshold=0.9, edge_type="sim_high")
    
    # 2. Run initial (should be empty for e1, e2, e3 as max sim is ~0.7)
    edges = g.run_induction(spec_id, mode="full")
    assert len(edges) == 0
    
    # 3. Add a new node very close to e1
    # e1 is [1, 0]. Add e1_copy = [0.99, 0.01]
    g.add_node(GraphNode(id="e1_copy", embedding=[0.999, 0.044])) # approx unit len, close to e1
    
    # 4. Run incremental
    # Should detect e1_copy <-> e1
    edges_inc = g.reapply_inductions_incremental()
    
    # reapply_inductions_incremental returns a list of results (one per inducer)
    # We have 1 inducer.
    assert len(edges_inc) == 1
    new_edges = edges_inc[0]
    
    pairs = sorted([(e.src_node_id, e.dst_node_id) for e in new_edges])
    assert ("e1", "e1_copy") in pairs
    assert ("e1_copy", "e1") in pairs
    
    # Should NOT re-evaluate e1-e2, e2-e3 etc. (though they wouldn't match anyway)
    # But specifically, it shouldn't return them even if they matched, if they were already processed.
    # (In this case they didn't match, so let's trust the logic verified in unit tests).

def test_bidirectional_incremental_predicate(simple_graph):
    g = simple_graph
    
    # Setup: Node A has val=1. Node B has val=1.
    # Inducer: Connect if val equals.
    
    g.add_node(GraphNode(id="A", attrs={"val": 100}))
    
    spec_id = g.add_predicate_induction(
        edge_type="same_val",
        generator_kind="all_pairs",
        predicates=[{
            "kind": "attr_equals",
            "params": {"src_attr": "attrs.val"}
        }],
        symmetric=False,
        incremental_mode="bidirectional"
    )
    
    g.run_induction(spec_id, mode="full")
    
    # Add Node B
    g.add_node(GraphNode(id="B", attrs={"val": 100}))
    
    # Incremental run
    # Should find A->B (Old->New) and B->A (New->Old)
    edges = g.run_induction(spec_id, mode="incremental")
    
    pairs = sorted([(e.src_node_id, e.dst_node_id) for e in edges])
    assert ("A", "B") in pairs
    assert ("B", "A") in pairs
